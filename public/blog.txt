WIP - mostly notes, might make a blog post.

Wanted to create a loaded dice simulation for the website.

To do this we used THREE.js to manage the 3d rendering of the dice.
For the physics engine we used CANNON.js

First step is rendering dice, a former colleague of mine would always say
"Let's get some pixels". To render the dice we could use a basic polygon cube as a
first step.

Next we want to apply gravity to the die and watch it fall to the ground.
We'll also need a ground. We use a THREE.js Plane to do this.

To cast the die we add some random forces on initialization.

However we wanted something which we could more easily
apply materials to and have things like concave spaces where the dice number is displayed.
In order for this level of detail we'll need a 3d model with a material.
With a material we can more easily configure things like colors and how light impacts the displayed object.
We found a creative commons 3d model on a website and went with that.
There are a number of websites to find something like this on.

Next we needed to know what number is facing up on the dice once it has stabilized.

To do this we need to compute the orientation of the die.
We can compute the orientation of the die by attaching points to each side of the die
and then performing all of the physics on the entire group, die and points.
After the dice is rotated we apply the rotation to these points and calculate
the point with the highest y position. That point indicates the top facing side.

// TODO: Update code to not compute die pos all the time?

This approach worked most of the time, and had an interesting look. Sometimes the dice would run into each other and be unable to rotate to their intended side.
Ultimately we decided this method seemed a little too 'loaded' and cartoonish.

What we wanted to do was have the dice always land on their intended sides without the extra push force at the end.
We had two options of how to do this:
1. Math it up and create an equation that would always land the dice with their intended side up, this could hard to do with the possible collisions involved.
2. Run the random simulation a lot of times and save the initial velocities of the tosses which achieve the intended lucky 7.
3. There may be other ways to use a physics engine to compute the intended side with fewer calculations and time elements.

Approach 1 seemed tempting, but I thought it could take a long time so I went with the less elegant and complete solution, #2.
We'll gather a large set of initial dice states, involving position, rotation, velocity, and angular velocity and use those values when running the simulation users see on the page.
With enough data entries this method will effectively give the same impression as the first method.

So we ran the simulation on an accelerated time scale about X times to gain X entries in our `LuckyNumbers` array.

The ending result is a lucky dice tossing simulation:

Thanks, the code is on github: 

Feel free to make suggestions or fix typos on this blog post on github: 



// TODO?
Next blog post we'll investigate how we pulled off the 3d rendering of an image
on a mug for Artsable.com - user submitted code.

